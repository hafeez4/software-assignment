# software-assignment


				PAPER#1: 
Title: DIGITAL RE-IMAGINATION OF SOFTWARE AND SYSTEMS PROCESSES
FOR QUALITY ENGINEERING:

			    
	         Authors: 
(i)Padmalata Nistala    (TCS Research)
(ii)Asha Rajbhoj           (TCS Research)
(iii)Vinay Kulkarni        (Tata Consultancy Services Research)
(iv)Kesave Vithal Nori  (IIIT Hyderabad)


Conferecne Name: The 42nd International conference on software and systems process.


Published: Friday,26 June 2020 at 17:10-17:25 at ICSSP-ICGSE-Session 1. 

				"Summary"
This paper was totally about the quality of software that are demanded by users now a now
according to needs of daily life, in this paper the existing infrastructure is discussed that are used
in industry for digital re-imagination of software and system processes. 
This paper contained information about  an ISPIN named framework that is useful 
in digital re-imagination of software and systems lifecycle processes. This framework is 
implemented using digital technolgies,they propose this framework for building an intelligent 
software process infrastructure, The proposed iSPIN framework will help in unprecedented automation and quality engineering at each process step and paves the way towards realizing the dictums of “Quality at Speed” and “Digital transformation of Software Process”. 

Research Methodology: This research paper starts to discuss that how software quality is important
and how much now a days is demanded by users, and ends at a proposed iSPIN framework implemented
using digital technologies that will be useful at "Quality at Speed" and "Digital transformation of software process.


Results: This paper realizes that how much software qulity is important and day by day it is increasing
according to needs of users.



					Paper#2
Title: A Case Study on Tool Support for Collaboration in
Agile Development

			Authors
1:	Fabio Calefato
2:	Andrea Giove
3:	Filippo Lanubile
4:	Marco Losovio

Conference Name:  International Conference on Program Comprehension (13-15 July 2020).

Published Date: Tue 14 Jul 2020 02:00 - 02:15 at ICPC - Session 4

SUMMARY:

The researcher report on a longitudinal case study conducted at the Italian site
of a large software company to further our understanding of how
development and communication tools can be improved to better
support agile practices and collaboration. After observing inconsistencies in the way 
communication tools (i.e., email, Skype, andSlack) were used, we first reinforced 
the use of Slack as the central hub for internal communication, while setting clear rules regarding
tools usage. As a second main change, we refactored the Jira Scrum
board into two separate boards, a detailed one for developers and
a high-level one for managers, while also introducing automation
rules and the integration with Slack. The first change revealed that
the teams of developers used and appreciated Slack differently with
the QA team being the most favorable and that the use of channels
is hindered by automatic notifications from development tools (e.g.,
Jenkins). The findings from the second change show that 85% of the
interviewees reported perceived improvements in their workflow.
Despite the limitations due to the single nature of the reported case,
we highlight the importance for companies to reflect on how to
properly set up their agile work environment to improve communication and facilitate collaboration.


Research Methodology:

Overall, the case study lasted for about four months, from December
2018 to April 2019. The collection of data happened along the entire
duration of the case study. There were four main data sources,
that is, documentation, direct observations, tools, and interviews, as
detailed next.
Documentation. During the case study, we had access to documentation of different kind, such as PowerPoint presentations
(describing the company’s development process at a higher level,
organization, and product architecture) and Excel spreadsheets (detailing project planning and performance analysis). Other helpful
sources of documentation were the Strengths, Weaknesses, Opportunities, Threats (SWOT) [8] and Balanced Scorecard [9] analysis
reports, which helped us understand the areas perceived by developers and management as susceptible to improvement.
Overall, the pieces of information retrieved from documentation sources were used to triangulate, integrate, and confirm those
obtained through the direct observation and semi-structured interviews, as described next.
Direct observations. Regarding direct observations, we could
attend 18 different sessions . The company allowed us
to participate in one Grooming session, seven Daily Meetings, and
two Sprint Reviews with the development teams. We agreed not
to take part in Retrospective meetings to avoid the risk of limiting
the free expression of problems reported by the development team
members. We also had the chance to participate in six KSTS-It
Management Board meetings and two Technical Board meetings.

Results:

In this paper, they reported on a case study conducted at KSTS-It,
the Italian site of a large, distributed software company. We analyzed their Agile tooling and work environment, and proposed a
couple of changes in the way they used Slack and Jira to improve
the collaboration. We found out that, overall, KSTS-It accepted the
restructured Slack workspace and the Jira automation rules, and reported more improvements in their communication and workflow.
As future work, KSTS-It is investigating the idea of extending
the role of Slack as a central communication hub by adding more
integrations with other tools, such as Confluence, and expanding
the set of automation rules in Jira. Finally, they are considering also
bringing to Berlin some of the changes investigated at the Italian
site.

				
				         The End


				Paper#3
Title: Linguistic Documentation of Software History

Authors: 
1: Miroslav Tushev 
2: Anas Mahmoud

Conference Name: International Conference on Program Comprehension (13-15 July 2020).
Publish Date: Tue 14 Jul 2020 02:00 - 02:15 at ICPC - Session 4

Summary:
In this paper the researcher discussed about the Large OSS projects, maintained by large distributed devel?oper teams, tend to have a rich history. Surveys of software
professionals revealed that software history is indispensable
for developers. Developers frequently ask questions
about the history of code to understand change rationale, track
bugs to their origin, or trace features to their older versions.
However, current version control systems (e.g. GitHub and
SourceForge) provide a single lens on history through com?mits. Commits record changes per file and line along with
developers’ descriptions of these changes. However, a large
percentage of change information is rarely documented.
Such non-informative commits have been identified as one
of the main challenges facing OSS developers examining
software history.
To address these limitations, in this Early Research Achieve?ments (ERA) paper, we propose a new window on software
history. In particular, we analyze software evolution through
the lens of developers’ language. The vocabulary
of this language, embedded in code identifier names, makes
up around 70% of code lexicon [8]. Research on program
comprehension revealed that identifiers capture developers’
understanding of their system and its application domain at
the most primitive level. Such information can be crucial for
developers during maintenance sessions ,
Comments were also found to play a paramount role in arriving at a correct understanding of
the program, especially for newcomers who do not have an
adequate experience in the internals of the system.
In the context of software, language evolution is typically
influenced by code evolution activities such as refactoring,
feature addition, and bug fixes. In our analysis, we hypothesize
that these different software evolution activities have different
impacts on the system’s vocabulary. Therefore, the ability to
capture and model the change in the system vocabulary is
expected to uncover the history of events that led to these
changes, revealing unique aspects of code evolution that are
typically overlooked by existing methods available in modern
version control systems, such as diff functions or Abstract
Syntax Trees (ASTs).
Our analysis is conducted using 32 open source systems,
their revisions and metadata. Our objective is to explore
the specific impacts of different maintenance tasks on the
linguistic identity of OSS projects and provide a preliminary
evidence on the nature and magnitude of this impact.
II. FOUNDATION AND ANALYSIS
In this paper, we aim to investigate linguistic change in
OSS projects. To conduct our analysis, we adapt Petersen et
al.’s [20] statistical model of natural language evolution to OSS
projects’ code lexicon. According to this model, a survival?of-the-fittest effect controls the way words emerge, grow, and
vanish throughout human history. Specifically, words are com?peting actors in a system of finite resources. Words can gain or
lose momentum influenced by historical events (e.g., war), new
innovations (e.g., penicillin), and socio-technological advances
(e.g., Internet). Such information can be
used to investigate linguistic trends quantitatively and explore
questions deeply-rooted in cultural anthropology .
In OSS development, the frequent maintenance actions
performed on the system as well as the highly dynamic nature
of developer teams, apply similar evolutionary pressures on
the usage and survival capacity of code lexicon words .
To understand and quantify the magnitude of this change,
we investigate the impact of different software maintenance
activities on OSS code lexicon. In general, we identify three
generic categories of such activities:
• Bug fixes: these activities include corrective maintenance
requests, mainly targeting bugs in the system, or errors
in the program’s logic.
• Feature additions: these activities typically include requests for new major, or minor, functionality to be added
to the system.
• Improvements: improvement activities typically include
perfective, adaptive, and preventive maintenance requests,
focusing on improving existing code by, for instance, enhancing the efficiency of underlying algorithms, improving code structure by refactoring, or improving interfaces.
Resolving the relationship between these different activities
and code change will provide a fundamental understanding of
the dynamics of linguistic change in OSS projects and bridge a
very important gap in code evolution research. In what follows,
we describe our data collection and analysis process in greater
detail.

Research Methodology:
The objective of our analysis is to examine whether linguistic change can be predicted by the different maintenance
activities performed on the project. To expose such effect, we
use Granger Causality, an econometric technique that is used
to test if one variable precedes another in a stationary timeseries [32]. Precisely, given the variables A and B, we test to
see if the values of A and the previous history of B predict the
values of B better, than the history of B alone. The assumption
behind using this test is that the different releases of the system
can be represented as points in a time series.
One of the parameters of Granger Causality is lag. The
operationalization of lag depends on the problem, or the
context. In our case, a lag of 1 represents the value of linguistic
change for release i and maintenance activities submitted in
the release notes for the same release i. Lag of 2 measures
the correlation between linguistic change of i-th release and
maintenance activities submitted for i-1 release, and so on.
Usually, in a time series analysis, several lag values are tested.
In our analysis, we measure lag of 1 and 2 for short term
impact and lag of 5 to capture long term impact.
To quantify the magnitude of linguistic shift in OSS
projects, we rely on Petersen et al.’s word-frequency
model [20]. According to this model, the linguistic change
rate (??i,j ) between two releases ri and rj of the system can
be calculated as the number of different words (words birth
and death) between the two releases divided by the number
of unique words in both releases. The average ?s of a system
s which has n releases can be calculated as the average ?i,j
between each two consecutive releases in the time series of the system.

Results:
To understand the relation between maintenance activities and linguistic change, they selected 32 projects from GitHub, covering four programming languages: Java, C#,
Python, and JavaScript. The criteria for selecting the projects
were a) the project should have a long history, or a
large number of releases, b) the project should be relatively popular, which can be quantified through the number of stars the project received on GitHub [26], and c)
the maintenance activities for each release of the project
should be explicitly classified by project maintainers. For
example, the Java project NewPipe in our dataset marks
feature additions as New (e.g., New: Basic MediaCCC
Support), bugs as Fixed (e.g., Fix random popup
player crash #2133), and other perfective tasks as
Improvements (e.g., Improvement: clearing watch
history using options menu). This criterion was enforced to ensure the validity of the results. Specifically, it can
be challenging to accurately classify the type of maintenance
activity if the issues related to the activity are not explicitly
defined. To collect our data, we used the GitHub API [29] to
download the top starred Java, C#, Python, and JavaScript
projects (8 x 4) along with their corresponding public releases.
This API provides a convenient way for directly downloading
project data (e.g., releases, commits, issues, contributors),
thus enabling access to all forms of events instigated by
code evolution activities. Selecting a smaller set of wellmaintained projects helps to mitigate the data validity threats
often associated with running experimentation on large-scale
datasets of OSS projects. The descriptive statistics of our
32 selected projects are provided in Table I.
To extract source code lexicon from our projects, we used
regular expressions. Code lexicon consists of all words used in
the source code except for the programming language specific
keywords. Regular expressions treat code artifacts as raw text
files. Therefore, the code itself does not have to compile,
or even to be complete, for regular expressions to work.
After identifiers are extracted, we further split any compound
words into their constituent words based on camel-casing (e.g.,
userID is split into User and ID) or any special characters.


				       The End
